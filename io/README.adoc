= MatlabTools :: IO

`MatlabTools::IO` is a library that allows importing and exporting MATLAB's Level 5 MAT-File format as documented in the official https://www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf[matfile_format.pdf].

The Level 5 format is also known as `MAT-File Version 7` and has been the default format for `.mat` and `.fig` files since `MATLAB R14` which was released in https://en.wikipedia.org/wiki/MATLAB#Release_history[2004]. For more information please refer to https://de.mathworks.com/help/matlab/import_export/mat-file-versions.html[MAT-File Versions].

== TL;DR

* Fluent API
* Advanced Filtering
* Concurrent Compression
* Memory Efficient Serialization
* Customized Serialization
* Undocumented MAT 5 Features
** `.fig` files
** `function handles`
** `handle` classes and new `string`, `table`, etc. types
** `Simulink` generated files with reduced header

For usage examples see link:./src/test/java/us/hebi/matlab/io/Mat5Examples.java[Mat5Examples] as well as other unit tests.

== Why a new library?

At https://www.hebirobotics.com/[HEBI Robotics] we maintain a Java based http://docs.hebi.us/tools.html#matlab-api[MATLAB API] for real-time control of robotic systems that needs to be able to efficiently write large (>2GB) MAT files while also supporting constrained heap spaces (<128MB).

Additionally, we wanted a way to add custom serialization schemes in order to save data streams with unknown amounts of data, without having to allocate large temporary matrices.

Since https://github.com/diffplug/matfilerw[MatFileRW] (maintained fork of https://github.com/gradusnikov/jmatio[JMatIO]) didn't support either use case, we ended up writing an internal library that was limited to serializing double matrices.  As sort of a learning experience, we recently spent some time to make the library full featured and decided to open source it.

Considering that there are many features that we don't have an internal use case for (e.g. reading MAT files), we welcome any feedback regarding missing features or suggested API changes.

== Highlights

Below is an overview of some of the highlights that may be of interest. The library is Java 6 compliant to support older versions of MATLAB, but it was developed with Java 8 syntax in mind.

=== Fluent API

All API classes have multiple overloads for the most commonly used methods in order to reduce clutter related to casting or temporary variables.

```Java
// Create MAT file with a scalar in a nested struct
try(Sink sink = Sinks.newStreamingFile("data.mat")){
    Mat5.newMatFile()
        .addArray("var1", Mat5.newString("Test"))
        .addArray("var2", Mat5.newScalar(7))
        .addArray("var3", Mat5.newStruct().set("x", Mat5.newScalar(42)))
        .writeTo(sink);
}
```

```Java
// Read scalar from nested struct
try(Source source = Sources.openFile("data.mat"){
    double value = Mat5.newReader(source).readFile()
        .getStruct("var3")
        .getMatrix("x")
        .getDouble(0);
}
```

More usage examples can be found in link:./src/test/java/us/hebi/matlab/io/Mat5Examples.java[Mat5Examples] and the various unit tests.

=== Advanced Filtering

In some cases we may only care about a subset of arrays, so there is no need to parse all of the content.

```Java
// Filter arrays that follow some criteria based on the name, type, dimension, or global/logical flags
try(Source source = Sources.openFile("data.mat"){
    MatFile mat = Mat5.newReader(source)
        .setArrayFilter(header -> header.isGlobal())
        .readFile();
}
```

Note that the filtering only gets applied on the root level, so nested arrays (e.g. inside a struct) won't be filtered separately.

=== Concurrent Compression

Almost all of the CPU time when reading or writing MAT files is spent on data compression. Fortunately, root entries are compressed independently from one another, so it's possible to do the work multi-threaded.

You can enable concurrent reading by passing an executor service into the reader. Doing this also requires a data source that supports sub-views on the underlying data, i.e., byte buffers or memory mapped files.

```Java
// Concurrent Decompression
ExecutorService executor = Executors.newFixedThreadPool(numThreads);
try(Source source = Sources.openFile("data.mat"){
    MatFile mat = Mat5.newReader(source)
        .enableAsyncDecompression(executor)
        .readFile()
} finally {
    executor.shutdown();
}
```

Concurrent writing unfortunately requires allocation of temporary buffers due to the size not being known beforehand. link:./src/main/java/us/hebi/matlab/io/experimental/ConcurrentMat5Writer.java[ConcurrentMat5Writer] is an experimental feature that shows how this could be implemented.

The table below shows a rough performance comparison of working with one of our production data logs. The data set was very multi-threading friendly (33x [95946x18] double matrices on the root level) and first loaded into memory to avoid disk access bottlenecks. The tests were done on a quad core with hyper-threading (Intel NUC6i7kyk).

[width="100%",options="header",cols="a,a,a,a,a"]
|====================
| Compression | Size | Threads | Write Time | Read Time
| BEST_COMPRESSION | 144 MB | 1 | 280 sec | 3.5 sec
| BEST_COMPRESSION | 144 MB | 8 | 47 sec | 0.8 sec
| BEST_SPEED | 156 MB | 1 | 7.2 sec | 3.6 sec
| BEST_SPEED | 156 MB | 8 | 1.5 sec | 0.8 sec
| NO_COMPRESSION | 422 MB | 1 | 0.07 sec | 0.2 sec
|====================

=== Memory Efficient Serialization

The MAT 5 format stores all data fields with a header tag that contains the number of bytes and how they should be interpreted. Rather than writing into temporary buffers to determine the serialized size, we added ways to pre-compute all deterministic sizes beforehand.

The only non-deterministic case is compressing data at the root level, which we can work around by writing a dummy size and overwriting it once the final size is known. Thus, enabling compression requires the root level sink to support position seeking (i.e. in-memory buffers, memory mapped files, or random access files).

==== Serializing Custom Classes

In order for a class to be serializable, it needs to implement the `Array` (or extend `AbstractArray`) and the `Mat5Serializable` interfaces. Below are examples:

* link:./src/test/java/us/hebi/matlab/io/experimental/EjmlDMatrixWrapper.java[EjmlDMatrixWrapper] serializes link:http://ejml.org[EJML]'s `DMatrix` type

* link:./src/test/java/us/hebi/matlab/io/experimental/EjmlSparseWrapper.java[EjmlSparseWrapper] serializes link:http://ejml.org[EJML]'s `DMatrixSparseCSC` sparse matrix

* link:./src/main/java/us/hebi/matlab/io/experimental/StreamingDoubleMatrix2D.java[StreamingDoubleMatrix2D] streams incoming row-major data into temporary files and combines them on serialization

=== Support for Undocumented Features

Unfortunately, MAT 5 files have several features that aren't covered in the official documentation. This includes most (all?) of the recently added types (`table`, `timeseries`, `string`, ...), `handle` classes, `function handles`, `.fig` files, `Simulink` outputs, etc.

The current implementation supports reading all of the `.mat` and `.fig` files we were able to generate. It also supports editing and saving of the loaded MAT files, e.g., adding entries, changing matrices, or using a different compression level. However, changes to the undocumented parts, such as setting a property on a `handle` class, will not be saved.

== Acknowledgements

https://github.com/diffplug/matfilerw[MatFileRW] (maintained fork of https://github.com/gradusnikov/jmatio[JMatIO]) served as an inspiration for parts of the implementation as well as a great source for test data. We ended up porting all of their unit tests with the exception of `Base64 MDL` decoding (all of the `MDL` files we found online were clear text and we couldn't figure out when that format is ever used).

The implementation for reading the undocumented `MCOS` (MATLAB Class Object System) data is based on https://github.com/mbauman[Matt Bauman]'s http://nbviewer.jupyter.org/gist/mbauman/9121961[reverse engineering efforts] as well as MatFileRW's implementation by https://github.com/MJDSys[Matthew Dawson].